

syntax = "proto2";
option go_package="operations_research;operations_research";
package operations_research;

// import "google/protobuf/wrappers.proto";

import "linear_solver.proto";

message ReferenceMPVariable {

// what else?
// remember you want to build an actual variable from this
// this could (or would) be the variable of another model?
// what about variable grouping?
// is this just an expression, 
// does expression include grouping as well
// okay maybe define expressions based on the reference variables

// we could be referencing to an expression??
// how we would know on the other side that refers to a var or expr?
// for both of expressions and constraints, we like to treat vars and exprs similarly
// otherwise we would need to create separate fields for them.

    optional string var_name = 5 [default = ""];

    optional string model_name = 6;

    optional int32 var_index = 7;

    optional string reference_name = 8;

    repeated string tags = 11;


}



message MPExpression {

    optional string name = 5 [default = ""];

    optional double lower_bound = 6 [default = -inf];
    optional double upper_bound = 7 [default = inf];

    optional double objective_coefficient = 8 [default = 0.0];

    repeated ReferenceMPVariable variables = 11 ;

    repeated double variable_coefficients =12;

    repeated string tags = 15;

}



message ExtendedMPModelProto {
    repeated MPVariableProto variable = 3;
  
    repeated MPConstraintProto constraint = 4;
  
    repeated MPGeneralConstraintProto general_constraint = 7;
  
    optional bool maximize = 1 [default = false];
  
    optional double objective_offset = 2 [default = 0.0];
  
    optional MPQuadraticObjective quadratic_objective = 8;
  
    optional string name = 5 [default = ""];

    optional PartialVariableAssignment solution_hint = 6;

    repeated MPExpression expressions =11;
}



message ReferenceMPConstraint {

    optional double lower_bound = 2 [default = -inf];
    optional double upper_bound = 3 [default = inf];

    optional string name = 4 [default = ""];

    repeated double coefficients = 7 [packed = true];  // Must be finite.

    repeated ReferenceMPVariable variable_references = 8;

}


message ReferenceMPModel {

    optional string name = 5 [default = ""];

    repeated MPVariableProto variables = 3;
  
    repeated MPConstraintProto constraints = 4;
  
    optional bool maximize = 1 [default = false];


    repeated ReferenceMPVariable reference_variables = 10;


    repeated ReferenceMPConstraint reference_constraints = 11;
  
    // double objective_offset = 2 [default = 0.0];
    // having the var references, does expressions help here? I 
    repeated MPExpression expressions =15;
    repeated string tags = 16;

    repeated string model_dependencies = 17;

    optional bool build_final = 20 [default = false];


}


message ExtendedMPModel {
    oneof extended_model {
        MPModelProto concrete_model =1;
        ReferenceMPModel reference_model =2;
    }

}

message ReferenceMPModelRequest {
    // The model to be optimized by the server.
    optional ExtendedMPModel model = 1;
}

//so we want to make a repetaed referencempmodel requests, so on the other side it would need to get them all and then figure out what to do

// need to add an rpc to return the concerete mip model